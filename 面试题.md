# 面试题总结

- [ Html和Css相关](#head1)
- [ Javascript相关](#head2)
	- [ 1.根据Promise/A+规范写一个Promise](#head3)
- [ React相关](#head4)
	- [ 1.为什么reducer是个纯函数？](#head5)
- [ 浏览器相关](#head6)
	- [ 1.浏览器常用储存技术](#head7)
	- [ 2.浏览器什么时候发生回流和重绘](#head8)
	- [ 3.Xss攻击](#head9)
	- [ 4.js的垃圾回收机制](#head10)
- [ 计算机网络相关](#head11)
	- [ 1.什么是二层转发和三层路由](#head12)
## <span id="head1"> Html和Css相关</span>

## <span id="head2"> Javascript相关</span>

##### <span id="head3"> 1.根据Promise/A+规范写一个Promise</span>

## <span id="head4"> React相关</span>

##### <span id="head5"> 1.为什么reducer是个纯函数？</span>

## <span id="head6"> 浏览器相关</span>

##### <span id="head7"> 1.浏览器常用储存技术</span>

**cookie** 其实最开始是服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，然后每次发起同源请求时，发送给服务器端。cookie 最多能存储 4 k 数据，它的生存时间由 expires 属性指定，并且 cookie 只能被同源的页面访问共享。
**sessionStorage** 是 HTML5 提供的一种浏览器本地存储的方法，它借鉴了服务器端 session 的概念，代表的是一次会话中所保存的数据。它一般能够存储 5 M 或者更大的数据，它在当前窗口关闭后就失效了，并且 sessionStorage 只能被同一个窗口的同源页面所访问共享。
**localStorage** 也是 HTML5 提供的一种浏览器本地存储的方法，它一般也能够存储 5 M 或者更大的数据。它和 sessionStorage 不同的是，除非手动删除它，否则它不会失效，并且 localStorage 也只能被同源页面所访问共享。
当我们大量储存数据时，我们可以使用浏览器的 indexDB 这是浏览器提供的一种本地的数据库存储机制。

##### <span id="head8"> 2.浏览器什么时候发生回流和重绘</span>

明确一点：回流必将引起重绘，重绘不一定会引起回流。
**回流**：1、页面首次渲染
2、添加或删除可见的dom
3、元素尺寸或者位置发生变化
4、元素内容发生变化
5、浏览器窗口大小改变
6、激活css伪类
7、查询某些属性或者调用某些方法
**重绘**：页面中元素样式的改变不影响其在文档流中的位置时，浏览器会将新样式赋予给元素并重新绘制它。

##### <span id="head9"> 3.Xss攻击</span>

XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。
XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。
XSS 一般分为存储型、反射型和 DOM 型。存储型指的是恶意代码提交到了网站的数据库中，当用户请求数据的时候，服务器将其拼接为 HTML 后返回给了用户，从而导致了恶意代码的执行。
反射型指的是攻击者构建了特殊的 URL，当服务器接收到请求后，从 URL 中获取数据，拼接到 HTML 后返回，从而导致了恶意代码的执行。
DOM 型指的是攻击者构建了特殊的 URL，用户打开网站后，JS 脚本从 URL 中获取数据，从而导致了恶意代码的执行。
XSS 攻击的预防可以从两个方面入手，一个是恶意代码提交的时候，一个是浏览器执行恶意代码的时候。
对于第一个方面，如果我们对存入数据库的数据都进行的转义处理，但是一个数据可能在多个地方使用，有的地方可能不需要转义，由于我们没有办法判断数据最后的使用场景，所以直接在输入端进行恶意代码的处理，其实是不太可靠的。
因此我们可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，我们对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。
还有一些方式，比如使用 CSP，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。
还可以对一些敏感信息进行保护，比如 cookie 使用 http-only ，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。

##### <span id="head10"> 4.JS垃圾回收机制</span>

- JavaScript拥有自动的垃圾回收机制，当一个值，在内存中失去引用时，垃圾回收机制会根据特殊的算法找到它，并将其回收，释放内存。
- **标记清除算法：**

1. 标记阶段，垃圾回收器会从根对象开始遍历。每一个可以从根对象访问到的对象都会被添加一个标识，于是这个对象就被标识为可到达对象。
2. 清除阶段，垃圾回收器会对堆内存从头到尾进行线性遍历，如果发现有对象没有被标识为可到达对象，那么就将此对象占用的内存回收，并且将原来标记为可到达对象的标识清除，以便进行下一次垃圾回收操作。
3. 缺点：垃圾收集后有可能会造成大量的 **内存碎片**。

- **引用计数算法：**

1. 引用计数的含义是跟踪记录每个值被引用的次数，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。
2. 缺点： 循环引用没法回收。

## <span id="head11"> 计算机网络相关</span>

##### <span id="head12"> 1.什么是二层转发和三层路由</span>

**二层转发**：这里应该用的为OSI分层模型，那么这里的二层指的是数据链路层，则是获取了数据的头部信息后，根据目标的MAC地址，进行本地的转发和广播（根据MAC地址选择发哪）也可指交换机。
**三层路由**：指的是网络层，则是设备工作在IP层，通过分析数据包头部信息，得到IP地址，根据网段范围，进行本地转发或选择下一个网关（也就是判断是否IP处于一个范围，不是就下一个再看）指路由器或者有路由功能的交换机。