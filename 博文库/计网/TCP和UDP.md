# TCP相关

## 1.TCP和UDP区别

**TCP特点**：

- 面向连接
- 可靠的
- 基于字节流

**UDP特点**：

- 面向无连接

**特点具体解析**：

1. **面向连接**：所谓的连接，指的是客户端和服务器的连接，在双方互相通信之前，TCP 需要三次握手建立连接，而 UDP 没有相应建立连接的过程。
2. **可靠性**：TCP的可靠性体现在它是一种有状态和可控制的协议。
   - **有状态**：TCP 会精准记录哪些数据发送了，哪些数据被对方接收了，哪些没有被接收到，而且保证数据包按序到达，不允许半点差错。这是**有状态**。
   - 当意识到丢包了或者网络环境不佳，TCP 会根据具体情况调整自己的行为，控制自己的发送速度或者重发。这是**可控制**。
3. **面向字节流**：UDP 的数据传输是基于数据报的，这是因为仅仅只是继承了 IP 层的特性，而 TCP 为了维护状态，将一个个 IP 包变成了字节流。

## 2.三次握手

### **2.1.三次握手**

![img](http://47.98.159.95/my_blog/tcp/001.jpg)

### 2.2.握手过程

1. 从最开始双方都处于`CLOSED`状态。然后服务端开始监听某个端口，进入了`LISTEN`状态。

2. 然后客户端主动发起连接，发送 SYN , 自己变成了`SYN-SENT`状态。

3. 服务端接收到，返回`SYN`和`ACK`(对应客户端发来的SYN)，自己变成了`SYN-REVD`。

4. 之后客户端再发送`ACK`给服务端，自己变成了`ESTABLISHED`状态；服务端收到`ACK`之后，也变成了`ESTABLISHED`状态。

### 2.3.相关问题

- **为什么要3次握手**？

  经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。

- **是否可以只用2次握手**？

  **两次握手表示**：客户端发送包含SYN的连接请求，服务端会回复ACK后就建立好连接了。

  1. 如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。
  2. 后来收到了确认，建立了连接。
  3. 数据传输完毕后，就释放了连接。

  在**过程1**中，**丢失的SYN报文段**如果因为在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端。此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接。**这时候服务端认为建立了连接**。

  - 服务端保持连接一直等待客户端发送数据，浪费资源

- **三次握手过程中可以携带数据么**？

  第三次握手的时候，可以携带。前两次握手不能携带数据。

  如果前两次握手能够携带数据，那么一旦有人想攻击服务器，那么他只需要在第一次握手中的 SYN 报文中放大量数据，那么服务器势必会消耗更多的**时间**和**内存空间**去处理这些数据，增大了服务器被攻击的风险。

  第三次握手的时候，客户端已经处于`ESTABLISHED`状态，并且已经能够确认服务器的接收、发送能力正常，这个时候相对安全了，可以携带数据。

- **syn洪泛攻击**：

  当第三次握手没有发送确认信息时，等待一段时间后，主机就会断开之前的半开连接并回收资源，这为dos（deny of service）攻击埋下隐患，当主动方主动发送大量的syn数据包，但并不做出第三次握手响应，server就会为这些syn包分配资源（但并未使用），就会使server占用大量内存，使server连接环境耗尽，这就是syn洪泛攻击。

## 3.四次挥手

### 3.1.四次挥手

![img](http://47.98.159.95/my_blog/tcp/002.jpg)

### 3.2.挥手过程

​      TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。这时对方会回一个ACK，此时一个方向的连接关闭。但是另一个方向仍然可以继续传输数据，等到发送完了所有的数据后，会发送一个FIN段来关闭此方向上的连接。接收方发送ACK确认关闭连接。注意，接收到FIN报文的一方只能回复一个ACK, 它是无法马上返回对方一个FIN报文段的，因为结束数据传输的“指令”是上层应用层给出的，我只是一个“搬运工”，我无法了解`“上层的意志”`。

1. 四次挥手可以分为两个部分，每个部分包含两次挥手，表示一个方向的连接断开。

   - 第一次挥手(FIN=1，seq=x)

     假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。
   
  发送完毕后，客户端进入 `FIN_WAIT_1` 状态。
   
- 第二次挥手(ACK=1，ACKnum=x+1)
   
     服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。
   
     发送完毕后，服务器端进入 `CLOSE_WAIT` 状态，客户端接收到这个确认包之后，进入 `FIN_WAIT_2` 状态，等待服务器端关闭连接。
   
   - 第三次挥手(FIN=1，seq=y)
   
     服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。
   
     发送完毕后，服务器端进入 `LAST_ACK` 状态，等待来自客户端的最后一个ACK。
   
   - 第四次挥手(ACK=1，ACKnum=y+1)
   
     客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 `TIME_WAIT`状态，等待可能出现的要求重传的 ACK 包。
   
     服务器端接收到这个确认包之后，关闭连接，进入 `CLOSED` 状态。
   
     客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 `CLOSED` 状态。

### 3.3.相关问题

**1.等待2MSL的意义**

如果不等待会怎样？

如果不等待，客户端直接跑路，当服务端还有很多数据包要给客户端发，且还在路上的时候，若客户端的端口此时刚好被新的应用占用，那么就接收到了无用数据包，造成数据包混乱。所以，最保险的做法是等服务器发来的数据包都死翘翘再启动新的应用。

那，照这样说一个 MSL 不就不够了吗，为什么要等待 2 MSL?

- 1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端
- 1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达

这就是等待 2MSL 的意义。

**2.为什么是四次挥手而不是三次？**

因为服务端在接收到`FIN`, 往往不会立即返回`FIN`, 必须等到服务端所有的报文都发送完毕了，才能发`FIN`。因此先发一个`ACK`表示已经收到客户端的`FIN`，延迟一段时间才发`FIN`。这就造成了四次挥手。

如果是三次挥手会有什么问题？

等于说服务端将`ACK`和`FIN`的发送合并为一次挥手，这个时候长时间的延迟可能会导致客户端误以为`FIN`没有到达客户端，从而让客户端不断的重发`FIN`。

## 4.流量控制

**流量控制**：为了避免分组丢失，**控制发送者的发送速度**，使得接收者来得及接收。

- 流量控制根本目的是防止分组丢失，它是构成TCP可靠性的一方面。

**流量控制实现**：由**滑动窗口协议**（连续ARQ协议）实现。滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。

- 主要的方式就是接收方返回的 ACK 中会**包含自己的接收窗口的大小**，并且**利用大小来控制发送方**的数据发送。

**ACK序号**：是期望接收到的下一字节的序号n，该n代表接收方已经接收到了前n-1字节数据，此时如果接收方收到第n+1字节数据而不是第n字节数据，接收方是不会发送序号为n+2的ACK的。

**窗口大小**： 当前的窗口大小m，如此发送方在接收到ACK包含的这两个数据后就可以计算出还可以发送多少字节的数据给对方，假定当前发送方已发送到第x字节，则可以发送的字节数就是y=m-(x-n).这就是滑动窗口控制流量的基本原理。

**流量控制引发的死锁**

**情况**：当发送者收到了一个窗口为0的应答，发送者便停止发送，等待接收者的下一个应答。**但是如果这个窗口不为0的应答在传输过程丢失**，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。

**解决**：为了避免流量控制引发的死锁，TCP使用了持续计时器。**每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小**。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免了死锁的产生。

## 5.拥塞控制

**拥塞控制**：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况。

发送方维持一个叫做**拥塞窗口的状态变量**。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。

常用的方法就是：

1. 慢开始、拥塞避免
2. 快重传、快恢复。

### 1. 慢开始、拥塞避免

**慢开始**：表示拥塞窗口从1开始，每过一个RTT，拥塞窗口加倍，直到窗口大小达到阈值。 **拥塞避免**: 达到阈值后，使用拥塞避免算法，每过一个RTT，增加1

- 遇到网络拥塞后，阈值变为现在的一半，然后窗口重新从1开始

发生拥塞出现的表现：

- 分组丢失（路由器缓存溢出）
- 分组延迟过大（在路由器缓存中排队）

### 2. 快重传、快恢复

**快重传**：要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方，可提高网络吞吐量约20%）而不要等到自己发送数据时捎带确认。

- 快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。

**快恢复**：当发送方连续收到三个重复确认时，就执行**乘法减小**算法，把拥塞窗口阈值减半（为了预防网络发生拥塞）。但是接下去并不执行慢开始算法，而是将当前发送的窗口设置为拥塞窗口阈值减半后的值，然后执行拥塞避免算法。