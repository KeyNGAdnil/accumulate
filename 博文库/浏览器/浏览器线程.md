# 浏览器线程

## 一、什么是进程和线程

在涉及浏览器多线程和js单线程之前，我们先铺垫一下前置概念：

#### 1、进程（process）

进程和线程都是操作系统的概念。

**进程是应用程序的执行实例，每个进程是由私有的虚拟地址空间、代码、数据和其它各种系统资源组成，即进程是操作系统进行资源分配和独立运行的最小单元。**

**当我们启动一个应用，计算机会至少创建一个进程，cpu会为进程分配一部分内存，应用的所有状态都会保存在这块内存中，应用也许还会创建多个线程来辅助工作，这些线程可以共享这部分内存中的数据。如果应用关闭，进程会被终结，操作系统会释放相关内存。**

mac电脑可以在活动监视器中查看启动的进程数：

![img](https://user-gold-cdn.xitu.io/2019/4/3/169e3126635bd439?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

*活动监视器*



#### 2、线程（thread）

- 进程内部的一个执行单元，是被系统独立调度和分派的基本单位。系统创建好进程后，实际上就启动执行了该进程的主执行线程
- 进程就像是一个有边界的生产厂间，而线程就像是厂间内的一个个员工，可以自己做自己的事情，也可以相互配合做同一件事情，所以**一个进程可以创建多个线程。**
- 线程自己不需要系统重新分配资源，它与同属一个进程的其它线程共享当前进程所拥有的全部资源。 **PS：** **进程之间是不共享资源和地址空间的,所以不会存在太多的安全问题，而由于多个线程共享着相同的地址空间和资源,所以会存在线程之间有可能会恶意修改或者获取非授权数据等复杂的安全问题。**

而现在通用叫法**单线程与多线程，都是指在一个进程内的单和多。**

如果对进程及线程的理解还存在疑惑，可以参考下述文章👇 [www.ruanyifeng.com/blog/2013/0…](http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html)

关于单核处理器、多核处理器、多处理器是怎么处理进程和线程的，可以参考下述文章👇 [blog.csdn.net/alinshen/ar…](https://blog.csdn.net/alinshen/article/details/80801303) [jsonliangyoujun.iteye.com/blog/235827…](https://jsonliangyoujun.iteye.com/blog/2358274)

## 二、浏览器的多进程

其实如果要开发一个浏览器，它可以是单进程多线程的应用，也可以是使用 IPC 通信的多进程应用。

![img](https://user-gold-cdn.xitu.io/2019/4/3/169e3139f77659cf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



不同浏览器采用了不同的架构模式，这里咱们只研究以**Chrome**为代表的浏览器：

**Chrome 采用多进程架构**。



![img](https://user-gold-cdn.xitu.io/2019/4/3/169e3143c3ec17c7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

*Chrome 的不同进程*



每打开一个tab页，就相当于于创建了一个独立的浏览器进程，这一点从上面的图中可以看出，但是也不是绝对的，它也有自己的优化机制，有的进程可能会被合并。

#### 1、**Chrome 的主要进程及其职责**

- **Browser Process** 浏览器的主进程（负责协调、主控） （1）负责包括地址栏，书签栏，前进后退按钮等部分的工作 （2）负责处理浏览器的一些不可见的底层操作，比如网络请求和文件访问 （3）负责各个页面的管理，创建和销毁其他进程
- **Renderer Process** 负责一个 tab 内关于网页呈现的所有事情，页面渲染，脚本执行，事件处理等
- **Plugin Process** 负责控制一个网页用到的所有插件，如 flash 每种类型的插件对应一个进程，仅当使用该插件时才创建
- **GPU Process** 负责处理 GPU 相关的任务



![img](https://user-gold-cdn.xitu.io/2019/4/3/169e314eb7d89ac7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

*不同进程负责的浏览器区域示意图*



Chrome 还为我们提供了「任务管理器」，供我们方便的查看当前浏览器中运行的所有进程及每个进程占用的系统资源，双击还可以查看更多类别信息。

通过「页面右上角的三个点点点 — 更多工具 — 任务管理器」即可打开相关面板。



![img](https://user-gold-cdn.xitu.io/2019/4/3/169e315987366fc3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

*任务管理器*



#### **2、Chrome 多进程架构的优缺点**

**优点：** （1）某一渲染进程出问题不会影响其他进程 （2）更为安全，在系统层面上限定了不同进程的权限

**缺点：** （1）由于不同进程间的内存不共享，不同进程的内存常常需要包含相同的内容。**为了节省内存，Chrome 限制了最多的进程数，最大进程数量由设备的内存和 CPU 能力决定，当达到这一限制时，新打开的 Tab 会共用之前同一个站点的渲染进程。**

Chrome 把浏览器不同程序的功能看做服务，这些服务可以方便的分割为不同的进程或者合并为一个进程。

以 Broswer Process 为例，如果 Chrome 运行在强大的硬件上，它会分割不同的服务到不同的进程，这样 Chrome 整体的运行会更加稳定，但是如果 Chrome 运行在资源贫瘠的设备上，这些服务又会合并到同一个进程中运行，这样可以节省内存。

## 三、浏览器的多线程

对我们fe来讲，最重要的是Renderer Process下的多线程，就是我们常说的浏览器内核。

Chrome浏览器为每个tab页面单独启用进程，因此每个tab网页都有由其独立的渲染引擎实例

**浏览器内核是多线程，在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：**

#### 1、GUI 渲染线程

负责渲染浏览器界面HTML元素,当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时,该线程就会执行。在Javascript引擎运行脚本期间,GUI渲染线程都是处于挂起状态的,也就是说被”冻结”了.

ps：重排和重绘的区别，有兴趣的话，请看👇的链接 [juejin.im/entry/68449…](https://juejin.im/entry/6844903453966204936)

#### 2、JavaScript引擎线程

JS内核，负责处理Javascript脚本程序。 一直等待着任务队列中任务的到来，然后解析Javascript脚本，运行代码。一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序。

**ps：** GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。

#### 3、定时触发器线程

- 定时器setInterval与setTimeout所在线程
- 浏览器定时计数器并不是由JavaScript引擎计数的 因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案。

#### 4、事件触发线程

- 用来控制事件轮询，JS引擎自己忙不过来，需要浏览器另开线程协助
- 当JS引擎执行代码块如鼠标点击、AJAX异步请求等，会将对应任务添加到事件触发线程中
- 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理任务队列的队尾，等待JS引擎的处理
- 由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）

#### 5、异步http请求线程

在XMLHttpRequest在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript引擎的处理队列中等待处理。

```js
let xhr = new XMLHttpRequest();   // 不兼容ie6及更低,创建ajax实例
  xhr.open('get',`json/banner.json?_${Math.random()}`); //打开请求：发送请求前的一些配置项,get有缓存，所以要加随机数，post不用
  xhr.onreadystatechange = ()=>{
     // 事件监听，ajax状态改变事件，基于这个事件可以获取服务器返回的响应头主体内容（响应头先回来）
     // 从这步开始，当前ajax任务开始，如果是同步的，后续代码不执行，要等到ajax状态成功后再执行，如果是异步的，不会
      if(xhr.readyState === 4 && /^(2|3)\d{2}$/.test(xhr.status)){
          //readyState 请求状态   // status 返回状态
          let data = JSON.parse(xhr.responseText);  // 获取响应主体的内容
      }
  };
  xhr.send(null); // 发送 ajax (括号中传递的内容就是请求主体的内容)
复制代码
```

这是一个简单的XMLHttpRequest请求的四个步骤，基于XMLHttpRequest的代表产品$.ajax，axios等。