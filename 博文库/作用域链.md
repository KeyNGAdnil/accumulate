# 作用域链

### 1.作用域

作用域是指有权访问的变量、函数和对象集合，换句话说就是变量与函数的可访问范围。作用域控制着变量与函数的可见性和生命周期。

作用域是一个独立的地盘，变量不会外泄和暴露出去，防止了不同作用域下同名变量的冲突可能。

ES6之前js没有块级作用域，只有全局作用域和函数作用域，直到ES6的 `let` 和 `const` 的出现。

### 2.全局作用域和函数作用域

#### 2.1.全局作用域

**定义**：在代码中任何地方都能访问到的对象拥有全局作用域。

以下几种情况拥有全局作用域：

- 在最外层函数外定义的变量拥有用全局作用域
- 所有未定义直接赋值的变量自动声明为拥有全局作用域
- 所有window对象的属性拥有全局作用域

**注意**：如果全局定义了太多的变量而没有用函数包括，可能会造成全局污染导致命名冲突。

#### 2.2.函数作用域

**定义**：指声明在函数内部的变量。局部作用域一般只能在固定的代码片段可访问。

```javascript
function doSomething(){
    var name="key";
    function doSomethingElse(){
        alert(name);
    }
    doSomethingElse();
}
alert(name); //脚本错误
doSomethingElse(); //脚本错误
```

作用域是分层的，内层作用域可以访问外层作用域的变量，反之则不行。

![img](https://user-gold-cdn.xitu.io/2019/3/8/169590b8c66f551b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

值得注意的是：**块语句（大括号“｛｝”中间的语句），如 if 和 switch 条件语句或 for 和 while 循环语句，不像函数，它们不会创建一个新的作用域**。在块语句中定义的变量将保留在它们已经存在的作用域中。

```javascript
if (true) {
    // 'if' 条件语句块不会创建一个新的作用域
    var name = 'Hammad'; // name 依然在全局作用域中
}
console.log(name); // logs 'Hammad'
```



### 3.块级作用域

 **定义：**当声明 `let` 和 `const` 变量时，会在所声明的指定块的位置生成一个块作用域，使得所声明的变量无法被外界访问。

块级作用域的创建有以下情况：

- 在一个函数内部
- 在一个代码块 `{}` 内部

### 4.作用域链

通俗地讲，当声明一个函数时，局部作用域一级一级向上包起来，就是作用域链。

1. 当执行函数时，总是先从函数内部找寻局部变量
2. 如果内部找不到（函数的局部作用域没有），则会向创建函数的作用域（声明函数的作用域）寻找，依次向上

```javascript
var a = 1;
function fn(){
	var a = 10;
    function fn1(){
		var a = 20;
        console.log(a);//20
    }
    function fn2(){
		console.log(a);//10
    }
    fn1();
    fn2();
}
fn();
console.log(a);//1
```

当执行fn1时，创建函数fn1的执行环境，并将该对象置于链表开头，然后将函数fn的调用对象放在第二位，最后是全局对象，作用域链的链表的结构是fn1->fn->window。从链表的开头寻找变量a，即fn1函数内部找变量a，找到了，结果是20。

同样，执行fn2时，作用域链的链表的结构是fn2->fn->window。从链表的开头寻找变量a，即fn2函数内部找变量a，找不到，于是从fn内部找变量a，找到了，结果是10。

最后在最外层打印出变量a，直接从变量a的作用域即全局作用域内寻找，结果为1。

### 5.作用域与执行上下文

其实作用域和执行上下文很容易被弄混淆，但事实并非如此。

大家都知道JavaScript属于解释型语言，代码执行分为解释和执行两个阶段。

**解释阶段**：

- 词法分析
- 语法分析
- 作用域构建

**执行阶段**：

- 创建执行上下文
- 执行代码
- 垃圾回收

JavaScript解释阶段就已经确定作用域的规则，而不是在函数被调用时确定，但执行上下文是在函数被执行之前创建，执行上下文最明显的就是this的指向是执行时确定的。而作用域访问的变量是编写代码的结构确定的。

作用域和执行上下文之间最大的区别是： **执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变**。