# 二叉树部分

[掘金二叉树总结](https://juejin.im/post/6844903600720707597)

[简书二叉树总结](https://www.jianshu.com/p/20c8881c6b86)

### 1.术语 

1. 节点的度：一个节点含有的子树的个数称为该节点的度；
2. 叶节点或终端节点：度为零的节点； 
3. 非终端节点或分支节点：度不为零的节点； 
4. 父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点； 
5. 兄弟节点：具有相同父节点的节点互称为兄弟节点； 
6. 节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推； 
7. 树的高度或深度：树中节点的最大层次； 
8. 堂兄弟节点：父节点在同一层的节点互为堂兄弟； 
9. 节点的祖先：从根到该节点所经分支上的所有节点； 
10. 孙：以某节点为根的子树中任一节点都称为该节点的子孙。 
11. 森林：由m（m>=0）棵互不相交的树的集合称为森林； 
12. 满二叉树：一棵深度为k，且有2^k-1 (2的k次方减一)个节点称之为满二叉树 
13. 完全二叉树：完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树

### 2.二叉树的性质

1.在非空二叉树中，第i层的结点总数不超过2^(i-1),i>=1； 

2.深度为h的二叉树最多有2^h-1个结点(h>=1)，最少有h个结点； 

3.对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0=N2+1； 

4.具有n个结点的**完全二叉树**的深度为**K =[log2n」+1(取下整数)** 

5.有N个结点的**完全二叉树**各结点如果用顺序方式存储，**则结点之间有如下关系： 若I为结点编号则 如果I>1，则其父结点的编号为I/2；** 

6.**完全二叉树，如果2\*I<=N，则其左儿子（即左子树的根结点）的编号为2\*I；若2\*I>N，则无左儿子； 如果2\*I+1<=N，则其右儿子的结点编号为2\*I+1；若2\*I+1>N，则无右儿子。** 

7.给定N个节点，能构成h(N)种不同的二叉树。h(N)为卡特兰数的第N项。h(n)=C(2*n，n)/(n+1)。 

8.设有i个枝点，I为所有枝点的道路长度总和，J为叶的道路长度总和J=I+2i

### 3.练习题

#### 1.二叉树前序遍历

概念：对于二叉树中的任意一个节点，先打印该节点，然后是它的左子树，最后右子树

<img src="https://pic.leetcode-cn.com/d7948dc5e50e70cc84cfbd0e0cf989da40eb96167f03b710392be45b8c415662.png" alt="img" style="zoom:33%;" />

[LeetCode题目地址](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/)

```javascript
//递归法
var preorderTraversal = (root) => {
    let result = [];
    var preOrderTraverseNode = (node) => {
        if(node) {
            // 先根节点
            result.push(node.val)
            // 然后遍历左子树
            preOrderTraverseNode(node.left)
            // 再遍历右子树
            preOrderTraverseNode(node.right)
        }
    }
    preOrderTraverseNode(root)
    return result
};
//迭代法
const preorderTraversal = (root) => {
    const list = [];
    const stack = [];
    
    // 当根节点不为空的时候，将根节点入栈
    if(root) stack.push(root)
    while(stack.length > 0) {
        const curNode = stack.pop()
        // 第一步的时候，先访问的是根节点
        list.push(curNode.val)
        
        // 我们先打印左子树，然后右子树
        // 所以先加入栈的是右子树，然后左子树
        if(curNode.right !== null) {
            stack.push(curNode.right)
        }
        if(curNode.left !== null) {
            stack.push(curNode.left)
        }
    }
    return list
}
```



#### 2.二叉树中序遍历

概念：对于二叉树中的任意一个节点，先打印它的左子树，然后是该节点，最后右子树

<img src="https://pic.leetcode-cn.com/c7b23b11e779559a5b0c53b3549c97ab5dbd49e7a867feed4fb4165b8ef4d495.png" style="zoom:33%;" />

[LeetCode题目地址](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

```javascript
//递归法
var inorderTraversal = function(root) {
    const res = [];
    const inorder = (root) => {
        if (!root) {
            return;
        }
        inorder(root.left);
        res.push(root.val);
        inorder(root.right);
    }
    inorder(root);
    return res;
};
//迭代法
var inorderTraversal = function(root) {
    const res = [];
    const stk = [];
    while (root || stk.length) {
        //将所有左节点压入栈
        while (root) {
            stk.push(root);
            root = root.left;
        }
        //按栈的顺序弹出
        root = stk.pop();
        res.push(root.val);
       	//将右节点压入栈
        root = root.right;
    }
    return res;
};
```



#### 3.二叉树后序遍历

概念：对于二叉树中的任意一个节点，先打印它的左子树，然后是右子树，最后该节点

<img src="https://pic.leetcode-cn.com/bad9b52cb37fc71193e419e886fb808bc7ea55462af53d5dffe6362950a27665.png" style="zoom: 33%;" />



[LeetCode题目地址](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

```JavaScript
//递归法
var inorderTraversal = function(root) {
    const res = [];
    const inorder = (root) => {
        if (!root) {
            return;
        }
        inorder(root.left);
        inorder(root.right);
        res.push(root.val);
    }
    inorder(root);
    return res;
};
//迭代法
const postorderTraversal = (root) => {
    const list = [];
    const stack = [];
    
    // 当根节点不为空的时候，将根节点入栈
    if(root) stack.push(root)
    while(stack.length > 0) {
        const node = stack.pop()
        // 根左右=>右左根
        list.unshift(node.val)
        
        // 先进栈左子树后右子树
        // 出栈的顺序就变更为先右后左
        // 右先头插法入list
        // 左再头插法入list
        // 实现右左根=>左右根
        if(node.left !== null) {
            stack.push(node.left)
        }
        if(node.right !== null) {
            stack.push(node.right)
        }
    }
    return list
}
```



#### 4.二叉树层序遍历

[LeetCode题目地址](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

- 思路：基于BFS广度优先遍历算法，还是利用层序遍历的方法，只不过要记录层级数进行当前层级的节点次数的循环并放入数组，最后才能实现题目的结构要求。

- 复杂度分析:
  - 时间复杂度：每个点进队出队各一次，故渐进时间复杂度为 O(n)
  - 空间复杂度：队列中元素的个数不超过 n 个，故渐进空间复杂度为 O(n)
  
  ```javascript
  var levelOrder = function (root) {
      // 边界处理
      if (!root) return []
  
      // 所需变量定义
      const res = [] // 结果集合
      const queue = [root] // 队列
  
      // 遍历 使用队列
      while (queue.length) {
          const curLevLen = queue.length // 记录当前层需遍历次数
          const curLevNodes = [] // 当前层 节点集合
  
          for (let i = 0; i < curLevLen; i++) {
              const node = queue.shift() // 依次 出队
              curLevNodes.push(node.val) // 依次 存入当前层 节点集合中
  
              node.left  && queue.push(node.left)  // 若存在左子节点 则入队 更新queue
              node.right && queue.push(node.right) // 若存在右子节点 则入队 更新queue
  
          }
  
          res.push(curLevNodes)
      }
  
      return res
  
  }
  ```
  
  

#### 5.二叉树最大深度

[LeetCode题目地址](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

```JavaScript
//递归法
var maxDepth = function(root) {
    // 递归终止条件 
    if(root == null) return 0;
    return Math.max(maxDepth(root.left) + 1, maxDepth(root.right) + 1);
};
//层序遍历
var maxDepth = function(root) {
    if(root == null) return 0;
    let queue = [root];
    let level = 0;
    while(queue.length) {
        let size = queue.length;
        while(size --) {
            let front = queue.shift();
            if(front.left) queue.push(front.left);
            if(front.right) queue.push(front.right);
        }
        // level ++ 后的值代表着现在已经处理完了几层节点
        level ++;
    }
    return level;
};
```



#### 6.二叉树最小深度

[LeetCode题目地址](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

```javascript
//递归
var minDepth = function(root) {
    if(root == null) return 0;
    // 左右孩子都不为空才能像刚才那样调用
    if(root.left && root.right)
        return Math.min(minDepth(root.left), minDepth(root.right)) + 1;
    // 右孩子为空了，直接忽略之
    else if(root.left)
        return minDepth(root.left) + 1;
    // 左孩子为空，忽略
    else if(root.right)
        return minDepth(root.right) + 1;
    // 两个孩子都为空，说明到达了叶子节点，返回 1
    else return 1;
};
//层序遍历
var minDepth = function(root) {
    if(root == null) return 0;
    let queue = [root];
    let level = 0;
    while(queue.length) {
        let size = queue.length;
        while(size --) {
            let front = queue.shift();
            // 找到叶子节点
            if(!front.left && !front.right) return level + 1;
            if(front.left) queue.push(front.left);
            if(front.right) queue.push(front.right);
        }
        // level ++ 后的值代表着现在已经处理完了几层节点
        level ++;
    }
    return level;
};
```

#### 7.二叉搜索树的第k大节点

[LeetCode题目地址](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

思路：二叉搜索树的特点就是节点大小顺序为左->中->右，所以通过中序遍历后的二叉树为从小到大的顺序排列，找到第res.length-k个元素就是第k大节点，第k小思路同理。

```javascript
var kthLargest = function(root, k) {
    const res=[];
    function dfs(root){
        if(!root) return null;
        dfs(root.left);
        res.push(root.val);
        dfs(root.right);
    }
    dfs(root);
    return res[res.length-k];
};
```

#### 8.二叉树中和为某一值的路径

[LeetCode题目地址](https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)

思路：深度优先遍历+递归回溯算法

```javascript
var pathSum = function (root, sum) {
    const res = [];
    const stack = [];
    function dfs(root, sum) {
        if (!root) return null;
        stack.push(root.val)
        sum = sum - root.val;
        if (sum == 0 && !root.left && !root.right) {
            res.push([...stack])
        }
        dfs(root.left, sum)
        dfs(root.right, sum)
        stack.pop()
    }
    dfs(root, sum)
    return res;
};
```

#### 9.对称二叉树

[LeetCode题目地址](https://leetcode-cn.com/problems/symmetric-tree/)

思路：递归方法实现。判断情况有三种：1.初始根节点为空则返回true。2.递归函数传入根节点的左右节点，判断是否都不存在，若都不存在则返回true。3.进行下层节点的递归

迭代法的实现：判断情况相仿，需要使用队列来存放节点。

```javascript
//递归
var isSymmetric = function (root) {
    let mirro = (left, right) => {
        if (!left && !right) return true;
        if (!left || !right || left.val !== right.val) {
            return false
        }
        return mirro(left.left, right.right) && mirro(left.right, right.left)
    }
    if (!root) return true;
    return mirro(root.left, root.right)
};
//迭代
var isSymmetric = function(root) {
    if(root == null) return true;
    let queue = [root.left, root.right];
    let node1, node2;
    while(queue.length) {
        node1 = queue.shift();
        node2 = queue.shift();
        // 两节点均为空
        if(!node1 && !node2)continue;
        // 一个为空一个不为空，或者两个节点值不相等
        if(!node1 || !node2 || node1.val !== node2.val) return false;
        queue.push(node1.left);
        queue.push(node2.right);
        queue.push(node1.right);
        queue.push(node2.left);
    }
    return true;
};
```

#### 10.输出镜像二叉树

[LeetCode题目地址](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)

```javascript
var mirrorTree = function (root) {
    if (!root) return null;
    [root.left, root.right] = [root.right, root.left]
    mirrorTree(root.left)
    mirrorTree(root.right)
    return root;
};
```
#### 11.二叉树所有路径

[LeetCode题目地址](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)

```JavaScript
var binaryTreePaths = function (root) {
    const path = [];
    const res = [];
    let dfs = (node) => {
        if (!node) return null;
        path.push(node);
        dfs(node.left)
        dfs(node.right)
        if (!node.left && !node.right) {
            res.push(path.map(item => item.val).join('->'))
        }
        path.pop();
    }
    dfs(root)
    return res;
};
```

#### 12.二叉树展开为链表

[LeetCode题目地址](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

```javascript 
var flatten = function(root) {
    while(root){
      let p=root.left;
      if(p){
        while(p.right) p=p.right;
        p.right=root.right;
        root.right=root.left;
        root.left=null
      }
      root=root.right;
    }  
};
```

