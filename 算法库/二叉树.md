# 二叉树部分

[掘金二叉树总结](https://juejin.im/post/6844903600720707597)

[简书二叉树总结](https://www.jianshu.com/p/20c8881c6b86)

### 1.术语 

1. 节点的度：一个节点含有的子树的个数称为该节点的度；
2. 叶节点或终端节点：度为零的节点； 
3. 非终端节点或分支节点：度不为零的节点； 
4. 父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点； 
5. 兄弟节点：具有相同父节点的节点互称为兄弟节点； 
6. 节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推； 
7. 树的高度或深度：树中节点的最大层次； 
8. 堂兄弟节点：父节点在同一层的节点互为堂兄弟； 
9. 节点的祖先：从根到该节点所经分支上的所有节点； 
10. 孙：以某节点为根的子树中任一节点都称为该节点的子孙。 
11. 森林：由m（m>=0）棵互不相交的树的集合称为森林； 
12. 满二叉树：一棵深度为k，且有2^k-1 (2的k次方减一)个节点称之为满二叉树 
13. 完全二叉树：完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树

### 2.二叉树的性质

1.在非空二叉树中，第i层的结点总数不超过2^(i-1),i>=1； 

2.深度为h的二叉树最多有2^h-1个结点(h>=1)，最少有h个结点； 

3.对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0=N2+1； 

4.具有n个结点的**完全二叉树**的深度为**K =[log2n」+1(取下整数)** 

5.有N个结点的**完全二叉树**各结点如果用顺序方式存储，**则结点之间有如下关系： 若I为结点编号则 如果I>1，则其父结点的编号为I/2；** 

6.**完全二叉树，如果2\*I<=N，则其左儿子（即左子树的根结点）的编号为2\*I；若2\*I>N，则无左儿子； 如果2\*I+1<=N，则其右儿子的结点编号为2\*I+1；若2\*I+1>N，则无右儿子。** 

7.给定N个节点，能构成h(N)种不同的二叉树。h(N)为卡特兰数的第N项。h(n)=C(2*n，n)/(n+1)。 

8.设有i个枝点，I为所有枝点的道路长度总和，J为叶的道路长度总和J=I+2i

### 3.练习题

1. 二叉树前序遍历

   概念：对于二叉树中的任意一个节点，先打印该节点，然后是它的左子树，最后右子树

   <img src="https://pic.leetcode-cn.com/d7948dc5e50e70cc84cfbd0e0cf989da40eb96167f03b710392be45b8c415662.png" alt="img" style="zoom:33%;" />

   [LeetCode题目地址](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/)

   ```javascript
   //递归法
   var preorderTraversal = (root) => {
       let result = [];
       var preOrderTraverseNode = (node) => {
           if(node) {
               // 先根节点
               result.push(node.val)
               // 然后遍历左子树
               preOrderTraverseNode(node.left)
               // 再遍历右子树
               preOrderTraverseNode(node.right)
           }
       }
       preOrderTraverseNode(root)
       return result
   };
   //迭代法
   const preorderTraversal = (root) => {
       const list = [];
       const stack = [];
       
       // 当根节点不为空的时候，将根节点入栈
       if(root) stack.push(root)
       while(stack.length > 0) {
           const curNode = stack.pop()
           // 第一步的时候，先访问的是根节点
           list.push(curNode.val)
           
           // 我们先打印左子树，然后右子树
           // 所以先加入栈的是右子树，然后左子树
           if(curNode.right !== null) {
               stack.push(curNode.right)
           }
           if(curNode.left !== null) {
               stack.push(curNode.left)
           }
       }
       return list
   }
   ```

   

2. 二叉树中序遍历

   概念：对于二叉树中的任意一个节点，先打印它的左子树，然后是该节点，最后右子树

   <img src="https://pic.leetcode-cn.com/c7b23b11e779559a5b0c53b3549c97ab5dbd49e7a867feed4fb4165b8ef4d495.png" style="zoom:33%;" />

   [LeetCode题目地址](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

   ```javascript
   //递归法
   var inorderTraversal = function(root) {
       const res = [];
       const inorder = (root) => {
           if (!root) {
               return;
           }
           inorder(root.left);
           res.push(root.val);
           inorder(root.right);
       }
       inorder(root);
       return res;
   };
   //迭代法
   var inorderTraversal = function(root) {
       const res = [];
       const stk = [];
       while (root || stk.length) {
           while (root) {
               stk.push(root);
               root = root.left;
           }
           root = stk.pop();
           res.push(root.val);
           root = root.right;
       }
       return res;
   };
   ```

   

3. 二叉树后序遍历

   概念：对于二叉树中的任意一个节点，先打印它的左子树，然后是右子树，最后该节点

   <img src="https://pic.leetcode-cn.com/bad9b52cb37fc71193e419e886fb808bc7ea55462af53d5dffe6362950a27665.png" style="zoom: 33%;" />

   

   [LeetCode题目地址](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

   ```JavaScript
   //递归法
   var postorderTraversal = function(root) {
     if (root) {
       return [...postorderTraversal(root.left), ...postorderTraversal(root.right), root.val]
     } else {
       return []
     }
   }
   //迭代法
   var postorderTraversal = function(root) {
     const printArr = []
     if (!root) return printArr
     const stack = []
     stack.push({ color: 'white', node: root })
   
     while (stack.length > 0) {
       const { color, node } = stack.pop()
       if (color === 'gray') {
         printArr.push(node.val)
       } else {
         stack.push({ color: 'gray', node })
         node.right && stack.push({ color: 'white', node: node.right })
         node.left && stack.push({ color: 'white', node: node.left })
       }
     }
   
     return printArr
   }
   ```

   

4. 二叉树层序遍历

   [LeetCode题目地址](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

- 思路：基于BFS广度优先遍历算法，还是利用层序遍历的方法，只不过要记录层级数进行当前层级的节点次数的循环并放入数组，最后才能实现题目的结构要求。
- 复杂度分析:
  - 时间复杂度：每个点进队出队各一次，故渐进时间复杂度为 O(n)
  - 空间复杂度：队列中元素的个数不超过 n 个，故渐进空间复杂度为 O(n)

```javascript
var levelOrder = function (root) {
    // 边界处理
    if (!root) return []

    // 所需变量定义
    const res = [] // 结果集合
    const queue = [root] // 队列

    // 遍历 使用队列
    while (queue.length) {
        const curLevLen = queue.length // 记录当前层需遍历次数
        const curLevNodes = [] // 当前层 节点集合

        for (let i = 0; i < curLevLen; i++) {
            const node = queue.shift() // 依次 出队
            curLevNodes.push(node.val) // 依次 存入当前层 节点集合中

            node.left  && queue.push(node.left)  // 若存在左子节点 则入队 更新queue
            node.right && queue.push(node.right) // 若存在右子节点 则入队 更新queue

        }

        res.push(curLevNodes)
    }

    return res

}

```



