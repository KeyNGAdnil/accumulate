# 链表部分

### 一、链表

用一组任意存储的单元来存储线性表的数据元素。一个对象存储着本身的值和下一个元素的地址。

- 需要遍历才能查询到元素，查询慢。
- 插入元素只需断开连接重新赋值，插入快。

#### 1.打印链表

```javascript
/**
 * 1.打印链表
*/
function printListFromTailToHead(head) {
    const array = [];
    while (head) {
        array.unshift(head.val);
        head = head.next;
    }
    return array;
}
```

#### 2.反转链表

[LeetCode题目地址](https://leetcode-cn.com/problems/reverse-linked-list/)

方法一：

- 思路: 设置一个前指针prev和推进指针curr，推进直到curr为空，返回prev.
- 复杂度分析:
  - 时间: O(n). 逐个推进故 O(n).
  - 空间: O(1). 只用到了常数级额外空间故 O(1).

方法二：

- 思路: 自递归无法存储推进状态所以无法尾递归，不断将 next 放入递归方法反转链表，结果.next = 当前节点. （Tip: 记得推进结果直到 next.next 为空）

- 复杂度分析:
  - 时间: O(n). 从最底层两个节点反转开始，每层时间复杂度均为 O(1), 总共 n-1 层递归，故时间复杂度为 O(n).
  - 空间: O(n). 递归调用栈消耗空间，共 n-1 层递归，故空间复杂度为 O(n).

方法三：

- 思路: 用 prev 和 curr 存储推进状态，直到 curr 为空则输出结果.
- 复杂度分析:
  - 时间: O(n). 等同于正常推进，故 O(n).
  - 空间: O(1). 尾递归方式，重复使用一个空间故空间复杂度为 O(1).

```javascript
/** 
 * 方法一、迭代
 * 复杂度分析:
 * 时间: O(n). 逐个推进故 O(n).
 * 空间: O(1). 只用到了常数级额外空间故 O(1).
 */
let reverseList = (head) => {
    if (!head) {
        return null;
    }
    let pre = null, cur = head;
    while (cur) {
        let next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
    return pre;
};
//方法一 简化
var reverseList = function(head) {
    let [prev, curr] = [null, head];
    while (curr) {
        [curr.next, prev, curr] = [prev, curr, curr.next];
    }
    return prev;
};
//方法二 自递归
var reverseList = function (head) {
    if (!head || !head.next) return head;
    // 存储当前节点的下一个节点
    let next = head.next;
    let reverseHead = reverseList(next);
    head.next = null;
    next.next = head;
    return reverseHead;
};
//方法三 尾递归
var reverseList = function(head) {
    return reverse(null, head);
};

function reverse (prev, curr) {
    if (!curr) return prev;
    // [curr.next, prev, curr] = [prev, curr.next, curr.next];
    let tmp = curr.next;
    curr.next = prev;
    return reverse(curr, tmp);
}
```

#### 3.合并2个排序的链表

[LeetCode题目地址](https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu/)

- 思路：这道题可以使用递归实现，新链表也不需要构造新节点，我们下面列举递归三个要素
  - 终止条件：两条链表分别名为 l1 和 l2，当 l1 为空或 l2 为空时结束
  - 返回值：每一层调用都返回排序好的链表头
  - 本级递归内容：如果 l1 的 val 值更小，则将 l1.next 与排序好的链表头相接，l2 同理
- 复杂度分析：
  - 时间复杂度：`O(n + m)`，其中 n 和 m 分别为两个链表的长度。因为每次调用递归都会去掉 l1 或者 l2 的头节点（直到至少有一个链表为空），函数 `mergeTwoList` 至多只会递归调用每个节点一次。因此，时间复杂度取决于合并后的链表长度，即 `O(n+m)`
  - 空间复杂度：O(n+m)，其中 n 和 m 分别为两个链表的长度。递归调用 `mergeTwoLists` 函数时需要消耗栈空间，栈空间的大小取决于递归调用的深度。结束递归调用时 mergeTwoLists 函数最多调用 `n+m` 次，因此空间复杂度为 `O(n+m)`

```javascript
//方法一 递归
var mergeTwoLists = function (l1, l2) {
    if (l1 == null) {
        return l2;
    }
    if (l2 == null) {
        return l1;
    }
    if (l1.val < l2.val) {
        l1.next = mergeTwoLists(l1.next, l2);
        return l1;
    } else {
        l2.next = mergeTwoLists(l1, l2.next);
        return l2;
    }
};
```

#### 4.链表倒数第k个结点

[LeetCode题目地址](https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/)

- 思路：双指针方法，右指针先走k步，然后左右指针一起走，直到右指针遇到链表尾，就返回左指针。

```javascript
function FindKthToTail(head, k) {
    if (!head || !k) return null;
    let left = head;
    let right = head;
    let index = 1;
    while (right.next) {
        right = right.next;
        index++;
        if (index > k) {
            left = left.next;
        }
    }
    return left.val;
};
```

#### 5.两个链表的第一个公共节点

[LeetCode题目地址](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)

- 思路：我们使用两个指针 node1，node2 分别指向两个链表 headA，headB 的头结点，然后同时分别逐结点遍历，当 node1 到达链表 headA 的末尾时，重新定位到链表 headB 的头结点；当 node2 到达链表 headB 的末尾时，重新定位到链表 headA 的头结点。这样，当它们相遇时，所指向的结点就是第一个公共结点。
- 复杂度分析：
  - 时间复杂度：O(M+N)
  - 空间复杂度：O(1）

```javascript
var getIntersectionNode = function(headA, headB) {
    if(!headA || !headB) {
        return null
    }
    var nodeA = headA;
    var nodeB = headB;
    while(nodeA !== nodeB) {
        nodeA = (nodeA === null) ? headB : nodeA.next
        nodeB = (nodeB === null) ? headA : nodeB.next
    }
    return nodeA
};
```

#### 6.链表中环的入口节点

[LeetCode题目地址](https://leetcode-cn.com/problems/linked-list-cycle-lcci/)

- 思路：先使用快慢指针检测链表是否有环路，然后设置一个头指针和慢指针开始移动，最后两个指针会在环的入口节点会和。（具体需要数学公式）

```javascript
var detectCycle = function (head) {
    //方法一  快慢指针
    if (head === null) return null;
    let slow = head, fast = head;
    //判断是否有环
    let hascycle = false;

    while (fast.next !== null && fast.next.next !== null) {
        slow = slow.next;
        fast = fast.next.next;
        if (slow === fast) {
            let curr = head
            while (curr !== slow) {
                curr = curr.next
                slow = slow.next
            }
            return curr
        }
    }
    return null
};
```

#### 7.删除链表中的节点

[LeetCode题目地址](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)

给定单链表的头指针和要删除的指针节点，在O(1)时间内删除该节点。

- 1.删除的节点不是尾部节点 - 将next节点覆盖当前节点
- 2.删除的节点是尾部节点且等于头节点，只剩一个节点 - 将头节点置为null
- 3.删除的节点是尾节点且前面还有节点 - 遍历到末尾的前一个节点删除

只有第三种情况时间复杂度是O(n)，且这种情况只会出现1/n次，所以算法时间复杂度是O(1)

```javascript
var deleteNode = function (head, node) {
        if (node.next) {
            node.val = node.next.val;
            node.next = node.next.next;
        } else if (node === head) {
            node = null;
            head = null;
        } else {
            node = head;
            while (node.next.next) {
                node = node.next;
            }
            node.next = null;
            node = null;
        }
        return node;
    };
```



#### 8.删除链表中重复的节点

[LeetCode题目地址](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)

方法1.存储链表中元素出现的次数

- 1.用一个map存储每个节点出现的次数
- 2.删除出现次数大于1的节点

此方法删除节点时可以使用上面总结的办法。

时间复杂度：O(n)

空间复杂度：O(n)

```javascript
    function deleteDuplication(pHead) {
      const map = {};
      if (pHead && pHead.next) {
        let current = pHead;
        // 计数
        while (current) {
          const val = map[current.val];
          map[current.val] = val ? val + 1 : 1;
          current = current.next;
        }
        current = pHead;
        while (current) {
          const val = map[current.val];
          if (val > 1) {
            // 删除节点
            console.log(val);
            if (current.next) {
              current.val = current.next.val;
              current.next = current.next.next;
            } else if (current === pHead) {
              current = null;
              pHead = null;
            } else {
              current = pHead;
              while (current.next.next) {
                current = current.next;
              }
              current.next = null;
              current = null;
            }

          } else {
            current = current.next;
          }
        }
      }
      return pHead;
    }
```

